---
description: 读取extract-buffer.md，将信号分发到领域文件，去重，然后清空缓冲区。请在新的专用session中运行——不要在工作session中运行。
---

# /sync

读取 `D:\Life_with_AI\profile\ai-infra\extract-buffer.md`，将每条信号分发到对应的目标文件，然后清空缓冲区。

---

## 文件引用

| 标签 | 文件 | 角色 | 访问方式 |
|------|------|------|----------|
| A | `extract-buffer.md` | 临时缓冲：读取后清空 | 读取 + 清空 |
| B | `Alex-coder.md` | 代码领域的当前认知状态 | 读取 + 写入 |
| C | `Alex-coder-log.md` | 仅追加的审计日志，供人工审视 | 仅追加（不读取） |
| D | `Alex-core.md` | 人格级特征、思维模式、核心偏好 | 仅读取（不写入） |

> 如果存在其他领域文件（如 `Alex-designer.md` + `Alex-designer-log.md`），对应领域的B/C逻辑相同。根据信号的内容领域路由，不是按 `来源` 字段路由（来源表示信号捕获的位置，不是它的领域）。

---

## B文件结构

B使用表格格式追踪认知状态：

```markdown
## 认知状态

| 知识点 | 认知缺陷 | 部分理解 | 已掌握 | 更新时间 |
|--------|---------|---------|--------|----------|
| PR提交流程 | | | ✓ | 2026-02 |
| git rebase vs merge | | ✓ | | 2026-02 |

## 通信规则

- {领域特定的偏好}
```

更新B时，将✓移到对应列并更新日期。新增条目添加行。清理时（已掌握超过30天），删除该行。

---

## 约束

- **只读** A、B、D
- **只追加到** C ——不读取C。C是仅追加的审计日志，供人工审视。读取它会引入不必要的token成本和上下文噪音，对信号处理没有任何帮助。
- **不写入** D ——/sync不修改core.md。如果某条信号可能需要更新D，将 `[core-candidate]` 条目记录到C，由用户手动审视。
- **不重新扫描**对话历史——所有信号来自A
- **不凭空创造** A中不存在的信号
- **保留** B中的所有现有内容——只追加或更新特定条目

---

## 预检查

处理前，验证A的状态：

- **A文件不存在** → 告知用户："extract-buffer.md未找到，请检查路径配置。"停止。
- **A文件存在但内容为空** → 告知用户："缓冲区为空，无需同步。"停止。
- **A文件存在且有内容** → 继续。

---

## 逐步执行

### 第一步：读取文件

完整读取A。完整读取B。完整读取D（仅用于去重和对比——不写入D）。

**不读取C。**

### 第二步：处理每条信号

对A中的每条信号，判断其类型并执行对应的路由规则。从A中每个extract块携带 `主题` 和 `来源` 字段，写入C时一并记录。

#### [cognition] → B + C

1. **检查B中是否有相同知识点的现有条目。**
   - 相同知识点 = 相同的概念/工具/流程，不论措辞差异（如"git rebase和merge"与"rebase和merge的区别"是同一个）
   - 如果现有条目的认知状态**相同**，此信号为重复 → 跳过B更新，仍记录到C
   - 如果现有条目的认知状态**更低**（如 认知缺陷→部分理解，部分理解→已掌握），将B中的✓移到更高列并更新日期 → 将升级记录到C
   - 如果现有条目的认知状态**更高**（如 已掌握→认知缺陷），这是**认知回退** → 将B中的✓移到更低列并更新日期 → 将回退记录到C
   - 如果**没有现有条目**，在B中添加新行 → 记录到C

2. **追加到C**，标注当前日期：
   ```
   [cognition] {知识点}：{旧状态} → {新状态}
     依据：{来自信号}
     来源：{工作区} | {主题}
   ```
   如果是首次出现，使用 `新增 → {状态}`。
   如果是回退，使用 `{旧状态} → {新状态}（回退）`。

#### [thinking] → C + 可能[core-candidate]

1. **始终追加到C**，标注当前日期：
   ```
   [thinking] {描述}
     依据：{来自信号}
     来源：{工作区} | {主题}
   ```

2. **对照D检查相关性**：
   - 如果该思维模式**未在D中体现**且看起来是持久特质 → 同时在C中追加 `[core-candidate]`：
     ```
     [core-candidate] {描述} — 如果模式持续可能需要更新core.md
     ```
   - 如果该思维模式**已在D中记录** → 无需额外操作
   - 如果该思维模式**矛盾于**D中的内容 → 同时在C中追加 `[core-candidate]` 并标注矛盾：
     ```
     [core-candidate] 与D矛盾："{现有条目}" — 新信号：{描述}
     ```

#### [preference] → B 和/或 [core-candidate]

1. **判断范围**：
   - 如果偏好是**领域特定的**（如"解释代码时用术语"） → 目标是B的通信规则部分
   - 如果偏好是**跨领域的**（如"别用比喻"、"直接说"） → 不写入D；改为在C中追加 `[core-candidate]`
   - 如果模糊，默认归B（更窄的范围更安全）

2. **对于目标为B的偏好，检查B中是否有语义相似的偏好**：
   - 如果语义等价的偏好已存在 → 跳过（重复）
   - 如果新偏好**矛盾于**现有偏好 → 用新的替换旧的，将变更记录到C
   - 如果没有现有等价项 → 添加到B

### 第三步：清理B

所有信号处理完成后：

- 如果B明显膨胀，审查是否有可以压缩或合并的条目
- 标记为 `已掌握` 超过30天且无进一步状态变化的条目可以从B中移除（它们保存在C中）
- 如果执行了清理，向用户报告

### 第四步：清空A

所有信号成功分发后，清空A的内容（保留文件，清空内容）。

### 第五步：报告

向用户提供摘要：

```
同步完成（{日期}）：
- 处理：{n}条信号，来自{m}个extract块
- B更新：{变更列表，或"无变更"}
- C追加：{条目数}
- Core候选记录：{数量，或"无"}
- 跳过重复：{数量}
- 缓冲区已清空
```

---

## 去重规则

去重是**语义层面的，不是字面层面的**。两条记录指向同一事物的条件：

1. 描述的是**相同的概念、工具或流程**（如"环境变量"和"env vars"和".env文件"如果指向同一个知识点，就是相同的）
2. 描述的是**相同的思维模式**（如"先验证再扩展"和"核心没跑通不做扩展"是同一个模式）
3. 描述的是**相同的偏好**（如"用术语"和"别把技术概念说得太简单"表达的是同一个偏好）

拿不准时，**保留两条** ——错误去重（丢失真实信号）比轻度冗余（可以手动清理）更糟。

---

## 边界情况

- **A中有多个extract块**：按时间顺序处理。后面的信号可能覆盖前面的信号（针对同一知识点）。
- **来自不同工作区的信号**：按内容领域路由，不按来源工作区路由。在 `Content_Creator` 中捕获的代码认知信号仍然进入coder领域文件。`来源` 字段记录在C中用于追溯，不用于路由。
- **同次sync中的矛盾信号**：如果A中两条信号矛盾（如一条说"认知缺陷"，另一条说"已掌握"针对同一知识点），使用**较后的**那条（它反映更近的状态）。
- **目标文件不存在**：如果某个领域文件（B/C）尚不存在，在写入前先用合适的结构创建它。
